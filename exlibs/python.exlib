# Copyright 2009 Ingmar Vanhassel
# Copyright 2013 Jorge Aparicio
# Copyright 2015 Pierre Lejeune
# Distributed under the terms of the GNU General Public License v2

# Based in part upon 'python.eclass' v1.32 from Gentoo, which is:
#   Copyright 1999-2004 Gentoo Foundation

# exparams:
#   has_bin ( format: true or false ) ( defaults to false )
#     whether the package installs a script into /usr/bin
#
#   has_lib ( format: true or false ) ( defaults to true )
#     whether the package installs a library into site-packages
#
#   blacklist ( format: none or "a x.y" ) ( empty by default )
#     python abis that don't work with this package
#
#     if empty: APIv1 will be used, otherwise APIv2 will be used
#
#     none: whitelist all abis
#
#     a: blocks a.{0,1,2,...}
#
#     x.y: blocks x.y
#
#   min_versions ( format: "a.b.c x.y.z" ) ( empty by default )
#     minimal working version for each python abi
#
#   python_opts ( format: "[foo][bar]" ) ( empty by default )
#     options that need to be enabled in dev-lang/python
#
#   multibuild ( format: true or false ) ( defaults to true )
#     whether the package can be built for several python abis
#     NOTE: At the moment, a package can only use one multibuild "class".
#           For example, it can be built for multiple python abis or multiple C abis,
#           but not both at the same time. If you want to build for 32 and 64 bit,
#           you have to set multibuild=false here.
#           Also, all of your python dependencies will have to be multibuild=false
#           because they need to be installed to the ${LIBDIR} with the right bitness.
#
#   multiunpack, work
#     see easy-multibuild.exlib
#
#   with_opt ( format: true or false ) ( defaults to false )
#     whether an option needs to be enabled to build python bindings
#
#   option_name ( format: foo ) ( defaults to python )
#     the name of the option that needs to be enabled to build python bindings
#
#   2to3 (format: true or false) ( defaults to false )
#     whether to use 2to3 prior to build
#     The following arrays can be defined:
#       PYTHON_2TO3_FIXES: array of fixes to apply. Can be empty.
#       PYTHON_2TO3_NOFIXES: array of fixes to NOT apply. Can be empty.
#       PYTHON_2TO3_PARAMS: array of files and directories to transform. Defaults to * if empty.

# example:
#   require python [ python_opts="[readline]" min_versions="3.1.1" \
#                    blacklist="2 3.3" with_opt=true ]
#
# generates:
#   OPTIONS="
#       python? ( ( python_abis: 3.1 3.2 ) [
#           number-selected = at-least-one
#       ] )
#   "
#
#   DEPENDENCIES="
#       python_abis:3.1? ( dev-lang/python:3.1[>=3.1.1][readline] )
#       python_abis:3.2? ( dev-lang/python:3.2[readline] )
#   "

myexparam -b has_lib=true
myexparam -b has_bin=false
myexparam -b 2to3=false

PYTHON_EXLIB_API=2

myexparam blacklist=

if [[ -z $(exparam blacklist) ]]; then
    PYTHON_EXLIB_API=1
fi

case ${PYTHON_EXLIB_API} in
    1)
        exparam -b 2to3 && export_exlib_phases src_prepare

        myexparam python_dep=

        if [[ $(exparam python_dep) == \[*\] ]] ; then
            die "Please migrate ${CATEGORY}/${PNV} to new python.exlib api v2."
        fi

        if exparam -b has_bin; then
            [[ -n $(exparam python_dep) ]] && DEPENDENCIES+="
            build+run:
                dev-lang/python:*[>=$(exparam python_dep)]
        "
        elif exparam -b has_lib; then
            [[ -n $(exparam python_dep) ]] && DEPENDENCIES+="
            build+run:
                dev-lang/python:=[>=$(exparam python_dep)]
        "
        fi

        export PYTHON="/usr/$(exhost --build)/bin/python"

        # Tells python not to automatically recompile modules to .pyc/.pyo even if the timestamps/version
        # stamps don't match. this is done to protect sandbox.
        #
        # NOTE: Supported by dev-lang/python[>=2.6] only.
        python_disable_pyc() {
            illegal_in_global_scope

            export PYTHONDONTWRITEBYTECODE=1
        }

        python_enable_pyc() {
            illegal_in_global_scope

            unset PYTHONDONTWRITEBYTECODE
        }

        # Returns the current python abi
        python_get_abi() {
            illegal_in_global_scope

            local python_abi

            # TODO(moben) this assumes that python == python2
            # hopefully we have migrated everything to API=2 of this exlib until that changes
            python_abi=$(eclectic python2 show)

            echo -n "${python_abi}"
        }

        # Run without arguments, returns the python include directory.
        python_get_incdir() {
            illegal_in_global_scope

            echo -n "/usr/$(exhost --target)/include/python$(python_get_abi)"
        }

        # Run without arguments, returns the python library directory.
        python_get_libdir() {
            illegal_in_global_scope

            echo -n "/usr/$(exhost --target)/lib/python$(python_get_abi)"
        }

        # Run without arguments, returns the python site-packages directory.
        python_get_sitedir() {
            illegal_in_global_scope

            echo -n "$(python_get_libdir)/site-packages"
        }

        # Byte-compiles all .py files in ${IMAGE}$(python_get_libdir). Changing the mtime of a .py file
        # invalidates the byte-compiled versions. python_bytecompile() should thus be run at the end of
        # src_install(). Both .pyc & .pyo (optimized & byte-compiled) files are generated.
        python_bytecompile() {
            illegal_in_global_scope

            [[ ${EXHERES_PHASE} != install ]] && die "${FUNCNAME} should only be run in src_install()"

            [[ -n ${@} ]] && die "${FUNCNAME} takes no arguments"

            edo find "${IMAGE}$(python_get_libdir)" -type f -name '*.py' -exec touch {} +

            local excludes=()
            [[ -n "${PYTHON_BYTECOMPILE_EXCLUDES[@]}" ]] && \
                excludes=( -x "$(IFS='|' ; echo "${PYTHON_BYTECOMPILE_EXCLUDES[*]}")" )

            edo python$(python_get_abi)    -mcompileall -f -q -d $(python_get_libdir) "${excludes[@]}" "${IMAGE}$(python_get_libdir)"
            edo python$(python_get_abi) -O -mcompileall -f -q -d $(python_get_libdir) "${excludes[@]}" "${IMAGE}$(python_get_libdir)"
        }

        if exparam -b 2to3; then
            python_src_prepare() {
                default

                python_run_2to3
            }
        fi
        ;;
    2)
        myexparam -b multibuild=true
        myexparam -b with_opt=false

        if exparam -b with_opt; then
            myexparam option_name=python
            exparam -v OPTION_NAME option_name

            MYOPTIONS="${OPTION_NAME}"
        fi

        myexparam python_opts=
        myexparam min_versions=

        exparam -v PYTHON_OPTS python_opts
        exparam -v PYTHON_BLACKLIST blacklist
        exparam -v PYTHON_MIN_VERSIONS min_versions

        # PYTHON_AVAILABLE_ABIS below need to be in sync with
        # MULTIBUILD_PYTHON_ABIS_TARGETS in profiles/make.defaults.
        PYTHON_AVAILABLE_ABIS="2.7 3.2 3.3 3.4"

        if [[ ${PYTHON_BLACKLIST} == none ]]; then
            PYTHON_FILTERED_ABIS="${PYTHON_AVAILABLE_ABIS}"
        else
            PYTHON_FILTERED_ABIS=

            for abi in ${PYTHON_AVAILABLE_ABIS}; do
                if has $(ever major ${abi}) ${PYTHON_BLACKLIST}; then
                    continue
                elif has ${abi} ${PYTHON_BLACKLIST}; then
                    continue
                fi

                PYTHON_FILTERED_ABIS+="${abi} "
            done

            if [[ -z ${PYTHON_FILTERED_ABIS} ]]; then
                die "all available python abis have been blacklisted"
            fi
        fi

        if exparam -b has_lib; then
            # NOTE: currently it's only possible to use classes C or PYTHON_ABIS
            if exparam -b multibuild; then
                myexparam -b multiunpack=false
                exparam -b multiunpack && myexparam work=${PNV} && exparam -v PYTHON_WORK work

                exparam -v PYTHON_MULTIUNPACK multiunpack

                require easy-multibuild [ classes=[ PYTHON_ABIS ] \
                                          multiunpack=${PYTHON_MULTIUNPACK} $(exparam -b multiunpack && echo "work=${PYTHON_WORK}") ]

                MULTIBUILD_PYTHON_ABIS_TARGETS="${PYTHON_FILTERED_ABIS}"
            fi

            MYOPTIONS+=' ('
            exparam -b with_opt && MYOPTIONS+=" ${OPTION_NAME}?"
            # define python subotions with description, requires and number_select
            MYOPTIONS+=" ( python_abis: ( ${PYTHON_FILTERED_ABIS} ) [["
            # set the maximum of enabled python_abis:*
            exparam -b multibuild && MYOPTIONS+=' number-selected = at-least-one' || MYOPTIONS+=' number-selected = exactly-one'
            MYOPTIONS+=' ]] ) )'

            DEPENDENCIES+="build+run: ( "
            exparam -b with_opt && DEPENDENCIES+="${OPTION_NAME}? "
            DEPENDENCIES+="( "
            for abi in ${PYTHON_FILTERED_ABIS};  do
                DEPENDENCIES+="python_abis:${abi}? ( dev-lang/python:${abi}"
                for min_version in ${PYTHON_MIN_VERSIONS}; do
                    if [[ $(ever range 1-2 ${min_version}) == ${abi} ]]; then
                        DEPENDENCIES+="[>=${min_version}]"
                        break
                    fi
                done
                DEPENDENCIES+="${PYTHON_OPTS} ) "
            done
            DEPENDENCIES+=") )"

            # set python version which we will build against, we need that until easy-multibuild is fixed
            # PYTHON_ABIS is set via the suboption
            if exparam -b multibuild; then
                if exparam -b 2to3; then
                    export_exlib_phases src_prepare src_configure src_compile src_test src_install
                else
                    export_exlib_phases src_configure src_compile src_test src_install
                fi

                python_run_phase() {
                    if exparam -b with_opt; then
                        option "${OPTION_NAME}" && easy-multibuild_run_phase
                    else
                        easy-multibuild_run_phase
                    fi
                }

                if exparam -b 2to3; then
                    python_src_prepare() {
                        python_run_phase
                    }

                    prepare_one_multibuild() {
                        default

                        python_run_2to3
                    }
                fi

                python_src_configure() {
                    python_run_phase
                }

                python_src_compile() {
                    python_run_phase
                }

                python_src_test() {
                    python_run_phase
                }

                python_src_install() {
                    python_run_phase
                    emagicdocs
                }
            else
                exparam -b 2to3 && export_exlib_phases src_prepare

                export PYTHON="/usr/$(exhost --build)/bin/python${PYTHON_ABIS}"

                if exparam -b 2to3; then
                    python_src_prepare() {
                        default

                        python_run_2to3
                    }
                fi
            fi
        else
            # TODO decide what to do with this part
            if exparam -b has_bin; then
                DEPENDENCIES+="
                    build+run:
                        ( $(exparam -b with_opt && echo "${OPTION_NAME}?") ( dev-lang/python:*${PYTHON_OPTS} ) )
                "
            fi
            export PYTHON="/usr/$(exhost --build)/bin/python"
        fi

        # Tells python not to automatically recompile modules to .pyc/.pyo even if the timestamps/version
        # stamps don't match. this is done to protect sandbox.
        #
        # NOTE: Supported by dev-lang/python[>=2.6] only.
        python_disable_pyc() {
            illegal_in_global_scope

            export PYTHONDONTWRITEBYTECODE=1
        }

        python_enable_pyc() {
            illegal_in_global_scope

            unset PYTHONDONTWRITEBYTECODE
        }

        # Returns the current python abi
        python_get_abi() {
            illegal_in_global_scope

            if exparam -b multibuild; then
                echo -n "${MULTIBUILD_PYTHON_ABIS_CURRENT_TARGET}"
            else
                echo -n "${PYTHON_ABIS}"
            fi
        }

        # Run without arguments, returns the python include directory.
        python_get_incdir() {
            illegal_in_global_scope

            echo -n "/usr/$(exhost --target)/include/python$(python_get_abi)"
        }

        # Run without arguments, returns the python library directory.
        python_get_libdir() {
            illegal_in_global_scope

            echo -n "/usr/$(exhost --target)/lib/python$(python_get_abi)"
        }

        # Run without arguments, returns the python site-packages directory.
        python_get_sitedir() {
            illegal_in_global_scope

            echo -n "$(python_get_libdir)/site-packages"
        }

        # Byte-compiles all .py files in ${IMAGE}$(python_get_libdir). Changing the mtime of a .py file
        # invalidates the byte-compiled versions. python_bytecompile() should thus be run at the end of
        # src_install(). Both .pyc & .pyo (optimized & byte-compiled) files are generated.
        python_bytecompile() {
            illegal_in_global_scope

            [[ ${EXHERES_PHASE} != install ]] && die "${FUNCNAME} should only be run in src_install()"

            [[ -n ${@} ]] && die "${FUNCNAME} takes no arguments"

            edo find "${IMAGE}$(python_get_libdir)" -type f -name '*.py' -exec touch {} +

            local excludes=()
            [[ -n "${PYTHON_BYTECOMPILE_EXCLUDES[@]}" ]] && \
                excludes=( -x "$(IFS='|' ; echo "${PYTHON_BYTECOMPILE_EXCLUDES[*]}")" )

            edo python$(python_get_abi)    -mcompileall -f -q -d $(python_get_libdir) "${excludes[@]}" "${IMAGE}$(python_get_libdir)"
            edo python$(python_get_abi) -O -mcompileall -f -q -d $(python_get_libdir) "${excludes[@]}" "${IMAGE}$(python_get_libdir)"
        }
        ;;
    *)
        die "Detecting python exlib api went wrong"
        ;;
esac

if exparam -b 2to3; then
    # Runs 2to3 to make source code compatible with Python-3.
    e2to3() {
        illegal_in_global_scope

        [[ ${EXHERES_PHASE} != prepare ]] && die "${FUNCNAME} should only be run in src_prepare()"

        local python_abi=$(python_get_abi) fixes=() nofixes=()

        [[ $(ever major ${python_abi}) != 3 ]] && die "${FUNCNAME} is for usage with python-3 only"

        [[ -n ${PYTHON_2TO3_PARAMS[@]} ]] || PYTHON_2TO3_PARAMS=( * )

        for fix in "${PYTHON_2TO3_FIXES[@]}"; do
            fixes+=( "--fix=${fix}" )
        done

        for nofix in "${PYTHON_2TO3_NOFIXES[@]}"; do
            nofixes+=( "--nofix=${nofix}" )
        done

        edo 2to3-${python_abi} -j${EXJOBS:-1} -wn --no-diffs "${fixes[@]}" "${nofixes[@]}" "${PYTHON_2TO3_PARAMS[@]}"
    }

    python_run_2to3() {
        illegal_in_global_scope

        local python_abi=$(python_get_abi)

        [[ $(ever major ${python_abi}) == 3 ]] && e2to3
    }
fi

